[{"content":"(Updated: April 5, 2022 ) 在上一篇文章，已經介紹如何安裝 Serverless Framework 以及註冊 AWS 帳號，接下來要組合使用AWS Lambda 和 DynamoDB 並透過 API gateway 的介導讓外部進行存取，實作一個記事本後端 CRUD API。\n用預設模板(template)建立服務 俗話說「萬丈高樓平地起」，建立一個無伺服器服務就從模板開始。\n在create命令加上--help列出幫助訊息，當中會列出有哪些預設模板可以用，不同的模板有不同的起始程式碼和設定。\nserverless create --help\r         --template 透過預設模板創建服務   --template-url 讀取遠端儲藏庫來創建服務   --path 指定創建服務的資料夾，不存在的話就會建立一個新的    我們要使用aws-nodejs這個模板來建立我們的服務:\nserverless create --template aws-nodejs --path serverless-notes-rest-api\rcd serverless-notes-rest-api\rnpm init -y\rserverless-notes-rest-api資料夾下面有三個檔案handler.js、serverless.yml 和package.json，雖然裡面是很陽春的程式碼和設定，我們還是可以先部署到 AWS 看看。\nserverless deploy --verbose\r 如果你在部署的過程中遇到錯誤，有可能是 AWS 帳戶權限給錯了，或是 serverless framework 讀不到正確的 credentials，所以最好在部署指令上加--verbose印出詳細的 log 去一一排除。\n 等部署完成後，調用 lambda function 測試一下:\nserverless invoke -l -f hello\r返回 status code 200 代表成功調用函式:\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: \u0026#34;{\\n \\\u0026#34;message\\\u0026#34;: \\\u0026#34;Go Serverless v1.0! Your function executed successfully!\\\u0026#34;,\\n \\\u0026#34;input\\\u0026#34;: {}\\n}\u0026#34; } -------------------------------------------------------------------- START END Duration: 2.66 ms Memory Used: 56 MB 撰寫 serverless.yml 基礎設施即代碼 (IaC)，用文件來記錄、管理雲端資源的配置，服務需要的函式定義、事件類型(ex. http, sns, s3\u0026hellip;等)、IAM權限、資料庫和物件儲存都記錄在 serverless.yml 文件中。當中大部分的設定，都需要去參考 AWS CloudFormation 的文件來撰寫。\n這次設定檔大致分為4個主要區塊 (provider、functions 、 resources 和 plugins)，拆解開來方便做說明，請再自行合併成一份檔案。\nprovider 可定義將服務部署至哪個雲端服務供應商，應用到全局的資源設定也會放在這裡，像是 Lambda function 的 runtime、timeout和 iam 等等，但是基於least-privilege permissions的原則，我們不將相同的 IAM role 應用到所有的 function，而是個別進行設定。\n更多的 provider 設定可參考這裡。\n# serverless.yml service: serverless-notes-api frameworkVersion: \u0026#34;3\u0026#34; provider: name: aws runtime: nodejs14.x stage: ${opt:stage, \u0026#39;dev\u0026#39;} region: us-east-1 # Function environment variables environment: AWS_NODEJS_CONNECTION_REUSE_ENABLED : 1 NOTES_TABLE_NAME: !Ref notesTable stage: ${opt:stage, 'dev'} 的意思是，用 serverless dploy 命令進行部署時，若參數--stage為空，預設值就會是 dev。這是相當方便的表示方式，有利於自動化和區分資源是用於開發環境或是生產環境。\nAWS_NODEJS_CONNECTION_REUSE_ENABLED 是指 Lambda function 運行 Node.js 時使用 AWS SDK 向其他服務(例如:DynamoDB)發起連線時，可重複使用尚未關閉的連線以避免重新連線的開銷。\nNOTES_TABLE_NAME: !Ref notesTable 取得 notesTable 資源所定義的 DynamoDB 表格名稱。\nfunctions 這裡要來定義實現 CRUD 功能的 Lambda function 的 IAM role 和 http event 的規格。\n# serverless.yml functions: createNote: handler: handler.createNote iamRoleStatements: - Effect: Allow Action: - dynamodb:PutItem Resource: !GetAtt notesTable.Arn events: - http: method: post path: notes updateNote: handler: handler.updateNote iamRoleStatements: - Effect: Allow Action: - dynamodb:UpdateItem Resource: !GetAtt notesTable.Arn events: - http: method: put path: notes/{id} deleteNote: handler: handler.deleteNote iamRoleStatements: - Effect: Allow Action: - dynamodb:DeleteItem Resource: !GetAtt notesTable.Arn events: - http: method: delete path: notes/{id} getAllNotes: handler: handler.getAllNotes iamRoleStatements: - Effect: Allow Action: - dynamodb:Scan Resource: !GetAtt notesTable.Arn events: - http: method: get path: notes handler: handler.createNote 表示 createNote 方法是透過 handler.js 匯出的。\niamRoleStatements 定義各個 function 的 IAM role，但是這種寫法需要另外安裝 plugin 才能在 serverless.yml 中使用。\nevents 中定義的 http 事件會在部署的時候建立相對應的 API Gateway。\nresources 這裡定義一個 DynamoDB 表格，包含名稱為noteId型別為字串 (S) 的 primary key。若是不屬於 primary key 或 sort key 的 attribute 就不需要寫在裡面。\n# serverless.yml resources: Resources: notesTable: Type: AWS::DynamoDB::Table Properties: TableName: notes-${self:provider.stage} BillingMode: PAY_PER_REQUEST AttributeDefinitions: - AttributeName: noteId AttributeType: S KeySchema: - AttributeName: noteId KeyType: HASH plugins 每個 fuction 個別定義IAM role 的話需要使用 serverless-iam-roles-per-function 這個外掛，安裝指令:\nnpm i --save-dev serverless-iam-roles-per-function\r# serverless.yml\rplugins:\r- serverless-iam-roles-per-function\rhandler.js 接下來，我們要將處理筆記本後端 CRUD 的 Lambda function handler 新增到handler.js，因為需要和 AWS DynamoDB 資料庫連線，借助 AWS SDK for JavaScript 這個套件進行開發，使得編寫程式碼變得相當簡單。請用下列指令安裝套件:\nnpm i aws-sdk\r\u0026#39;use strict\u0026#39;; const DynamoDB = require(\u0026#34;aws-sdk/clients/dynamodb\u0026#34;); const documentClient = new DynamoDB.DocumentClient({ region: process.env.REGION }); const NOTES_TABLE_NAME = process.env.NOTES_TABLE_NAME; const response = (statusCode, data) =\u0026gt; { return { statusCode, body: JSON.stringify(data), }; }; module.exports.createNote = async (event, context, callback) =\u0026gt; { context.callbackWaitsForEmptyEventLoop = false; console.log(event); let data = JSON.parse(event.body); try { const params = { TableName: NOTES_TABLE_NAME, Item: { noteId: data.id, title: data.title, content: data.content, }, // The PutItem operation will not overwrite the item with the same key, if the item exists.  ConditionExpression: \u0026#34;attribute_not_exists(noteId)\u0026#34;, }; await documentClient.put(params).promise(); callback(null, response(201, data)); } catch (err) { callback(null, response(500, err.message)); } }; module.exports.updateNote = async (event, context, callback) =\u0026gt; { context.callbackWaitsForEmptyEventLoop = false; let noteId = event.pathParameters.id; let data = JSON.parse(event.body); try { const params = { TableName: NOTES_TABLE_NAME, Key: { noteId }, UpdateExpression: \u0026#34;set #title = :title, #content = :content\u0026#34;, ExpressionAttributeNames: { \u0026#34;#title\u0026#34;: \u0026#34;title\u0026#34;, \u0026#34;#content\u0026#34;: \u0026#34;content\u0026#34;, }, ExpressionAttributeValues: { \u0026#34;:title\u0026#34;: data.title, \u0026#34;:content\u0026#34;: data.content, }, ConditionExpression: \u0026#34;attribute_exists(noteId)\u0026#34;, }; await documentClient.update(params).promise(); callback(null, response(200, data)); } catch (err) { callback(null, response(500, err.message)); } }; module.exports.deleteNote = async (event, context, callback) =\u0026gt; { context.callbackWaitsForEmptyEventLoop = false; let noteId = event.pathParameters.id; try { const params = { TableName: NOTES_TABLE_NAME, Key: { noteId }, ConditionExpression: \u0026#34;attribute_exists(noteId)\u0026#34;, }; await documentClient.delete(params).promise(); callback(null, response(200, noteId)); } catch (err) { callback(null, response(500, err.message)); } }; module.exports.getNotes = async (event, context, callback) =\u0026gt; { context.callbackWaitsForEmptyEventLoop = false; console.log(JSON.stringify(event)); try { const params = { TableName: NOTES_TABLE_NAME, }; const notes = await documentClient.scan(params).promise(); callback(null, response(200, notes)); } catch (err) { callback(null, response(500, err.message)); } }; context.callbackWaitsForEmptyEventLoop = false; 設為 false 將會在 callback 執行時立即傳送回應，而不會因為event loop 不為空，而等待到超時。這個在使用 async 非同步的情況下很好用，避免因為一些資料庫的連線事件導致 function 無法結束執行。\n部署 \u0026amp; 測試 部署到 AWS\nserverless deploy --verbose\r 開發期間，由於 function 修改得很頻繁，可以只要部署 function 就好。例如我只要更新雲端上的 createNote:\nserverless deploy function -f createNote\r或是只要更新特定 function 的設定:\nserverless deploy function -f createNote --update-config\r 成功部署之後，登入AWS，進入 API Gateway 的 APIs 頁面，表格中可以看到剛部署好的 dev-serverless-notes-api，點選他進入頁面後在左側欄位選 Stages 如下圖:\n點選 /notes 的 GET method 並複製頁面最上方的 Invoke URL，貼到 postman 測試。\n用 GET method 查詢目前存在的筆記，但是因為尚未新增任何筆記資料，所以拿到的結果 Items 是一個空陣列。\n 如果中途發生錯誤，記得善用 CloudWatch 進行除錯。每個 Lambda function 都會對應一個 log groups，記錄每一次的請求與回應的詳細訊息。\n 用 POST method 來新增一筆資料。\n實際到 DynamoDB 可以看到剛剛新增的一筆資料。\n用 PUT method 修改筆記，記得路徑要用 /notes/{id} 指定修改哪一筆紀錄。\n再用 GET method 查詢一下所有的筆記紀錄，可以看到回傳的筆記是已經被修改的狀態。\n刪除服務 最後，如果不再需要這個服務的話記得將它清空，避免產生不必要的支出。\nserverless remove\rReference  Serverless Framework - Serverless.yml Reference Serverless Framework - Deploy Function  ","permalink":"https://rcguo.github.io/posts/2021/build_a_crud_api_with_api_gateway_lambda_and_dynamodb/","summary":"(Updated: April 5, 2022 ) 在上一篇文章，已經介紹如何安裝 Serverless Framework 以及註冊 AWS 帳號，接下來要組合使用AWS Lambda 和 DynamoDB 並透過 API gateway 的介導讓外部進行存取，實作一個記事本後端 CRUD API。\n用預設模板(template)建立服務 俗話說「萬丈高樓平地起」，建立一個無伺服器服務就從模板開始。\n在create命令加上--help列出幫助訊息，當中會列出有哪些預設模板可以用，不同的模板有不同的起始程式碼和設定。\nserverless create --help\r         --template 透過預設模板創建服務   --template-url 讀取遠端儲藏庫來創建服務   --path 指定創建服務的資料夾，不存在的話就會建立一個新的    我們要使用aws-nodejs這個模板來建立我們的服務:\nserverless create --template aws-nodejs --path serverless-notes-rest-api\rcd serverless-notes-rest-api\rnpm init -y\rserverless-notes-rest-api資料夾下面有三個檔案handler.js、serverless.yml 和package.json，雖然裡面是很陽春的程式碼和設定，我們還是可以先部署到 AWS 看看。\nserverless deploy --verbose\r 如果你在部署的過程中遇到錯誤，有可能是 AWS 帳戶權限給錯了，或是 serverless framework 讀不到正確的 credentials，所以最好在部署指令上加--verbose印出詳細的 log 去一一排除。","title":"無伺服器實作入門 - 使用 AWS Lambda 和 DynamoDB 實作無伺服器 CRUD API"},{"content":"無伺服器架構不是真的沒有伺服器，而是將管理伺服器基礎架構的責任轉移到雲服務供應商(AWS、Azure等)身上，從而簡化軟體開發過程，使開發團隊更專注在實現商業邏輯和產品的開發。\n基礎設施即代碼 (IaC) 基礎設施即代碼 (IaC)對於軟體開發來說很重要，也是常被忽略的一環。雖然雲服務有提供圖形化的網頁介面控制台來配置無伺服器架構，一開始功能少的時候手動操作還應付得來，但是當功能拆分變多、業務規模變大時，對於測試、部署和環境管理配置就很難達到可重複性和一致性的需求。因此一開始就學習所謂的「正確姿勢」，對於後續開發、維護上的效率就能有所提升。\n無伺服器框架可以滿足自動化部署服務的需求，由於我們會將無伺服器搭建在AWS上，所以可以選擇的框架有 AWS SAM 和 Serverless Framework。兩個都是開源框架，但是前者是專門針對 AWS 服務所開發的，而後者則支援多個不同的雲端供應商，如果後續要轉換到其他雲端進行開發，則框架還可以繼續沿用。\n本文選擇使用 Serverless Framework 作為本次搭建的工具。\n安裝 Serverless Framework 使用 Node.js 套件管理器 NPM 來安裝 serverless CLI:\nnpm install -g serverless\r 官方也有提供 binary 執行檔的安裝方法 Installing Serverless Framework as a standalone binary\n 安裝完後輸入下方指令檢查一下，確認執行路徑有指向安裝框架的位置:\nserverless --version\r註冊 AWS 並創建 Programmatic access 帳號 如果你沒有 AWS 帳號，首先要去註冊(sign up)一個 Root user，需要填寫信用卡資訊才能註冊。註冊資料填寫過程在此不詳述。\n註冊成功後用 Root user 登入。由於 Root user 具有完全控制的管理員權限，基於安全理由官方建議(AWS account root user credentials and IAM user credentials )應該建立一個 IAM user 來存取 AWS 資源。由於篇幅的關係在此不詳述，附上官方文件操作說明 Creating IAM users (console)，希望大家都能遵照這個安全原則進行操作。\n登入後，接下來建立要給無伺服器框架用的帳號。\n 和一般帳號的差別在於 AWS credential type 項目只會勾選 「Access key - Programmatic access」，供無伺服器框架存取 AWS 資源使用。\n 在網頁上方的搜尋列輸入 iam 並點選 IAM 服務。 網頁左側的側邊攔點選 Users ，然後右上角點選 Add users。 在 User name 欄位輸入一個好辨識的名稱，AWS credential type 項目勾選 「Access key - Programmatic access」，點選下一步。 這裡要附加 policy 來賦予帳號的存取權限。選擇 Attach existing policies directly 分頁並勾選 「AdministratorAccess」，點選下一步。 tags 這裡留白，點選下一步。 Review 頁面不進行任何操作，點選下一步。 最後一個步驟，可以看到無伺服器部署轉用帳號建立完成，下載 CSV 格式的 credentials 檔案並妥善保存，不要讓其他人輕易取得該檔案。\n 注意!! AWS僅提供一次 credentials 檔案下載，錯過的話需要重新創建一次帳號才能再次下載。\n serverless CLI 設定 credentials 打開終端機輸入以下指令，把 credentials 檔案中的 Access key ID 和 Secret access key 對應到指令 --key 和 --secret 參數。\nserverless config credentials --provider aws --key \u0026lt;access_key_id\u0026gt; --secret \u0026lt;secret_access_key\u0026gt; AWS 憑證資訊會被寫入 ~/.aws (Unix/Linux) 或 C:\\Users\\\u0026lt;username\u0026gt;\\.aws (Windows) 路徑下的 credentials 檔案，如下所示:\n[default]\raws_access_key_id=AKIXXXXXXXXXXXXXXXXX\raws_secret_access_key=cxXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n到這裡已經完成了無伺服框架的安裝以及雲端帳號的設定，下一篇我們會建立一個簡單的無伺服器服務。\nReference  Serverless Framework AWS account root user credentials and IAM user credentials  ","permalink":"https://rcguo.github.io/posts/2021/setting_up_serverless_framework/","summary":"無伺服器架構不是真的沒有伺服器，而是將管理伺服器基礎架構的責任轉移到雲服務供應商(AWS、Azure等)身上，從而簡化軟體開發過程，使開發團隊更專注在實現商業邏輯和產品的開發。\n基礎設施即代碼 (IaC) 基礎設施即代碼 (IaC)對於軟體開發來說很重要，也是常被忽略的一環。雖然雲服務有提供圖形化的網頁介面控制台來配置無伺服器架構，一開始功能少的時候手動操作還應付得來，但是當功能拆分變多、業務規模變大時，對於測試、部署和環境管理配置就很難達到可重複性和一致性的需求。因此一開始就學習所謂的「正確姿勢」，對於後續開發、維護上的效率就能有所提升。\n無伺服器框架可以滿足自動化部署服務的需求，由於我們會將無伺服器搭建在AWS上，所以可以選擇的框架有 AWS SAM 和 Serverless Framework。兩個都是開源框架，但是前者是專門針對 AWS 服務所開發的，而後者則支援多個不同的雲端供應商，如果後續要轉換到其他雲端進行開發，則框架還可以繼續沿用。\n本文選擇使用 Serverless Framework 作為本次搭建的工具。\n安裝 Serverless Framework 使用 Node.js 套件管理器 NPM 來安裝 serverless CLI:\nnpm install -g serverless\r 官方也有提供 binary 執行檔的安裝方法 Installing Serverless Framework as a standalone binary\n 安裝完後輸入下方指令檢查一下，確認執行路徑有指向安裝框架的位置:\nserverless --version\r註冊 AWS 並創建 Programmatic access 帳號 如果你沒有 AWS 帳號，首先要去註冊(sign up)一個 Root user，需要填寫信用卡資訊才能註冊。註冊資料填寫過程在此不詳述。\n註冊成功後用 Root user 登入。由於 Root user 具有完全控制的管理員權限，基於安全理由官方建議(AWS account root user credentials and IAM user credentials )應該建立一個 IAM user 來存取 AWS 資源。由於篇幅的關係在此不詳述，附上官方文件操作說明 Creating IAM users (console)，希望大家都能遵照這個安全原則進行操作。","title":"無伺服器實作入門 - 安裝 Serverless Framework"},{"content":"PDF(Portable Document Format)是工作上常會用到的一種文件格式，有較不容易修改、傳輸方便、設備相容性和印刷品質較佳等優點。一般我們開發的軟體要自動發報告、帳單或收據給客戶，也都會優先選擇PDF為主要格式。\n合併PDF是目前加入浮水印的一種簡便方法，當浮水印樣式和內容固定的情況下開發會較為單純。本文以Pyhton的PyPDF4套件為例，雖然PyPDF4和PyPDF2不完全兼容，但此範例中所導入的函示方法和PyPDF2一樣，將套件名稱改掉後程式碼可以互相通用。\n用來示範的兩份PDF檔案，original_doc.pdf 和 watermark.pdf，程式會將浮水印合併到 original_doc.pdf 每一頁。\n   original_doc.pdf watermark.pdf          套件安裝 首先，安裝最新版的PyPDF4 (以下指令基於python3):\npip3 install PyPDF4\r合併浮水印 merge_watermark()是實現合併浮水印的方法，每當合併完一頁PDF浮水印就透過writer實例立刻輸出。\nfrom PyPDF4 import PdfFileWriter, PdfFileReader def merge_watermark(input_pdf, output_pdf, watermark): \u0026#34;\u0026#34;\u0026#34; Merge watermark to target PDF \u0026#34;\u0026#34;\u0026#34; watermark_obj = PdfFileReader(watermark) watermark_page = watermark_obj.getPage(0) pdf_reader = PdfFileReader(input_pdf) pdf_writer = PdfFileWriter() # Add watermark to each page  for page_num in range(pdf_reader.getNumPages()): page = pdf_reader.getPage(page_num) page.mergePage(watermark_page) pdf_writer.addPage(page) with open(output_pdf, \u0026#39;wb\u0026#39;) as f: pdf_writer.write(f) ArgumentParser 程式就是要能夠帶參數才可以方便使用。使用ArgumentParser解析並傳遞參數給Python程式碼。\n          -i --input 參數指定要被加入浮水印的PDF檔案路徑   -o --output 參數指定檔案輸出路徑，指定的路徑資料夾不存在就創建新的；但如果不指定輸出路徑，預設就會將檔案命名\u0026lt;原PDF檔名\u0026gt;-watermarked.pdf並輸出至原始PDF所在的資料夾。   -w --watermark 參數指定浮水印PDF檔案路徑    def parse_arguments(): \u0026#34;\u0026#34;\u0026#34; Parse command line arguments \u0026#34;\u0026#34;\u0026#34; parser = ArgumentParser(description=\u0026#34;Add watermarks to PDF in path\u0026#34;) parser.add_argument(\u0026#34;-i\u0026#34;, \u0026#34;--input\u0026#34;, help=\u0026#34;Path to input PDF\u0026#34;, required=True, type=str) parser.add_argument(\u0026#34;-o\u0026#34;, \u0026#34;--output\u0026#34;, help=\u0026#34;Path to output PDF\u0026#34;) parser.add_argument(\u0026#34;-w\u0026#34;, \u0026#34;--watermark\u0026#34;, help=\u0026#34;Path to watermark PDF\u0026#34;, required=True, type=str) return parser.parse_args() def main(): args = parse_arguments() source_pdf = os.path.abspath(args.input) source_dir = os.path.dirname(source_pdf) fname, f_ext = os.path.splitext(os.path.basename(source_pdf)) if args.output is None: ofname = os.path.join(source_dir, \u0026#39;{}{}{}\u0026#39;.format(fname, \u0026#34;-watermarked\u0026#34;, f_ext)) else: ofname = os.path.abspath(args.output) output_dir = os.path.dirname(ofname) try: if not os.path.exists(output_dir): os.makedirs(output_dir) except EnvironmentError: sys.exit(\u0026#34;Unable to create folder: \u0026#34; + output_dir) if os.path.isfile(source_pdf): merge_watermark( input_pdf = source_pdf, output_pdf = ofname, watermark = args.watermark ) else: sys.exit(\u0026#34;\\nPDF file {} not exists!\\n\u0026#34;.format(source_pdf)) if __name__ == \u0026#39;__main__\u0026#39;: import os import sys from argparse import ArgumentParser main() \n將程式儲存命名為 watermark.py 就可以來執行看看。\npython3 watermark.py -i original_doc.pdf -w watermark.pdf 輸出結果請見下圖。\n   original_doc-watermarked.pdf         以本人實際開發經驗來說，如果浮水印本來就屬於PDF該有的內容，應該在一開始撰寫模板的時候就考慮進去，到後面使用合併的方式其實都算是最後手段了。\nReference  https://github.com/claird/PyPDF4 A Complete Guide on How to Work With a PDF in Python  ","permalink":"https://rcguo.github.io/posts/2020/python_watermark/","summary":"PDF(Portable Document Format)是工作上常會用到的一種文件格式，有較不容易修改、傳輸方便、設備相容性和印刷品質較佳等優點。一般我們開發的軟體要自動發報告、帳單或收據給客戶，也都會優先選擇PDF為主要格式。\n合併PDF是目前加入浮水印的一種簡便方法，當浮水印樣式和內容固定的情況下開發會較為單純。本文以Pyhton的PyPDF4套件為例，雖然PyPDF4和PyPDF2不完全兼容，但此範例中所導入的函示方法和PyPDF2一樣，將套件名稱改掉後程式碼可以互相通用。\n用來示範的兩份PDF檔案，original_doc.pdf 和 watermark.pdf，程式會將浮水印合併到 original_doc.pdf 每一頁。\n   original_doc.pdf watermark.pdf          套件安裝 首先，安裝最新版的PyPDF4 (以下指令基於python3):\npip3 install PyPDF4\r合併浮水印 merge_watermark()是實現合併浮水印的方法，每當合併完一頁PDF浮水印就透過writer實例立刻輸出。\nfrom PyPDF4 import PdfFileWriter, PdfFileReader def merge_watermark(input_pdf, output_pdf, watermark): \u0026#34;\u0026#34;\u0026#34; Merge watermark to target PDF \u0026#34;\u0026#34;\u0026#34; watermark_obj = PdfFileReader(watermark) watermark_page = watermark_obj.getPage(0) pdf_reader = PdfFileReader(input_pdf) pdf_writer = PdfFileWriter() # Add watermark to each page  for page_num in range(pdf_reader.getNumPages()): page = pdf_reader.","title":"使用PyPDF4在PDF文件加入浮水印(watermark)"},{"content":"開發的時候曾經遇到一個情況，需要在 shell 執行程式時將 stderr 導向 console，但是不能顯示stdout 的訊息，且必須同時 stderr 和 stdout 記錄到 log 檔案。\n文件描述符 (file descriptor) 在 UNIX/Linux 系統中，是使用非負整數(0, 1, 2, \u0026hellip;)來表示文件描述符(file descriptor, fd)，用於標示系統中打開的文件和資源。 系統預設打開 0 (stdin), 1 (stdout), 2 (stderr)，也是我們平常常用到的描述符。\n接下來會將需求實作出來，並舉幾個例子以及需要注意的地方:\n 藉由ls一個不存在的檔案來測試，並將 stderr 訊息導向 error.log，我們cat檔案可以看到錯誤訊息:ls: cannot access foo.txt: No such file or directory。  ls foo.txt 2\u0026gt;error.log  將 stderr 導向 stdout，指令中 \u0026amp;(ampersand)符號是告訴shell我們把 fd 2 導向 fd 1 這個fd而不是一個檔案名稱。 在linux下，一切皆檔案，所以系統背後所做的事情是將 fd 1 複製給 fd 2。  ls foo.txt 2\u0026gt;\u0026amp;1  以下的指令先將 stdout 導向 error.log，所以之後 2\u0026gt;\u0026amp;1 重導向會將錯誤訊息寫入 syslog.log 中。 (一般1\u0026gt;syslog.log會省略1寫成＞error.log)  ls foo.txt 1\u0026gt;syslog.log 2\u0026gt;\u0026amp;1  這個指令和剛剛指令很像，要特別注意的是，有些人可能會理解成 「先把 stderr 導向 stdout，後面再把 stdout 導向 error.log，所以 stderr 和 stdout 都會寫入 syslog.log」。  ls foo.txt 2\u0026gt;\u0026amp;1 1\u0026gt;syslog.log 實際上則是 fd 2 複製原本的 fd 1 指向它目前指向的位置也就是 console ，之後 fd 1 會被導向到 syslog.log ，但 fd 2 所複製的副本不受影響，所以錯誤訊息會被印到 console ，stdout 會被存入檔案。\nTee 到這裡已經實作出需求的一半了，但是錯誤訊息尚未被存入檔案，這時候我們可以用 tee 將某個指令的標準輸出，導向、存入某個檔案中。\nls -l的輸出被導向 tee，並且複製到檔案 file.txt 以及下一個命令\n(圖片來源: https://zh.wikipedia.org/wiki/Tee)\n 可以看到 stderr 輸出到 console 並用管線將 console 內容傳給 tee 存入檔案。因此該指令也就能達成我們原本的需求。  ls foo.txt 2\u0026gt;\u0026amp;1 1\u0026gt;syslog.log | tee syslog.log Reference  Ampersands and File Descriptors in Bash 鳥哥的 Linux 私房菜 Wiki - tee  ","permalink":"https://rcguo.github.io/posts/2020/linux_shell_redirect_stderr_stdout/","summary":"開發的時候曾經遇到一個情況，需要在 shell 執行程式時將 stderr 導向 console，但是不能顯示stdout 的訊息，且必須同時 stderr 和 stdout 記錄到 log 檔案。\n文件描述符 (file descriptor) 在 UNIX/Linux 系統中，是使用非負整數(0, 1, 2, \u0026hellip;)來表示文件描述符(file descriptor, fd)，用於標示系統中打開的文件和資源。 系統預設打開 0 (stdin), 1 (stdout), 2 (stderr)，也是我們平常常用到的描述符。\n接下來會將需求實作出來，並舉幾個例子以及需要注意的地方:\n 藉由ls一個不存在的檔案來測試，並將 stderr 訊息導向 error.log，我們cat檔案可以看到錯誤訊息:ls: cannot access foo.txt: No such file or directory。  ls foo.txt 2\u0026gt;error.log  將 stderr 導向 stdout，指令中 \u0026amp;(ampersand)符號是告訴shell我們把 fd 2 導向 fd 1 這個fd而不是一個檔案名稱。 在linux下，一切皆檔案，所以系統背後所做的事情是將 fd 1 複製給 fd 2。  ls foo.txt 2\u0026gt;\u0026amp;1  以下的指令先將 stdout 導向 error.","title":"Linux Shell 重新導向: 將標準錯誤(stderr)輸出到螢幕和檔案"},{"content":"做為一名軟體工程師，工作也有幾年的時間了，一直都有紀錄和分享的想法，心裡卻擔心要分享的東西是不是太簡單了，或是不夠高大尚，老實說是我多慮了，對於現代人來說:\n 網路其實是人腦的延伸\n 寫程式寫到一半上網查個指令或程式碼片段，對工程師來說是家常便飯，你覺得簡單的東西人可能不覺得簡單。將知識消化的過程記錄下來，給了自己能回溯學習的機會，也給了其他人參考學習的來源。\n相信每個人一定都有一個最熟悉的「主」語言，雖然說語言只是完成事情的工具，但是隨著程式語言不斷演進和開發需求的不同，懂得越多意味著擁有更多選擇，能用不同方式來解決同樣的問題。\n 如果你只有槌子，看甚麼都像釘子\n 因此，持續學習不同程式語言或新知識對於工程師來說就是一項必備的能力，但不要以為看懂了就能記起來，除非你是記憶力的人，否則其實大部分人都需要時常複習和練習，才能把知識變成是自己的東西。\n做筆記 雖然市面上有許多種筆記軟體可供選擇，個人還是習慣使用文字檔寫個 Markdown 存在雲端，依照語言或項目做分類。當然，選擇自己慣用的方法即可。\n 筆記整理得多了，有時候也能幫助別人\n 例如，對某項技術比較生疏的同事，我就可以用15分鐘整理一份簡略版筆記讓他上手;想在小組內達成某個技術上的共識，也可以做一份簡報在小組會議的時候做分享。\n能夠教別人才是真的懂 常常發現自己縱使做了筆記，也實作了一些成果出來，但當要跟別人說明時卻又說不出個所以然、吚吚啊阿講不到核心重點，事實上是因為自己也不是很懂。\n 撰寫文章也是「刻意練習」的一種方式\n 撰寫文章是最簡單的刻意練習方式，但和作筆記不同。撰寫文章會刻意的將得到的知識重複檢視並加以消化，這個過程往往可以發現自己誤解或不甚了解之處。透過不斷重複這些步驟: 學習 -\u0026gt; 筆記 -\u0026gt; 組織成文章，記錄的資訊量愈大，我們就愈能理解自己關注的領域。\n","permalink":"https://rcguo.github.io/posts/2020/my_first_hugo_blog/","summary":"做為一名軟體工程師，工作也有幾年的時間了，一直都有紀錄和分享的想法，心裡卻擔心要分享的東西是不是太簡單了，或是不夠高大尚，老實說是我多慮了，對於現代人來說:\n 網路其實是人腦的延伸\n 寫程式寫到一半上網查個指令或程式碼片段，對工程師來說是家常便飯，你覺得簡單的東西人可能不覺得簡單。將知識消化的過程記錄下來，給了自己能回溯學習的機會，也給了其他人參考學習的來源。\n相信每個人一定都有一個最熟悉的「主」語言，雖然說語言只是完成事情的工具，但是隨著程式語言不斷演進和開發需求的不同，懂得越多意味著擁有更多選擇，能用不同方式來解決同樣的問題。\n 如果你只有槌子，看甚麼都像釘子\n 因此，持續學習不同程式語言或新知識對於工程師來說就是一項必備的能力，但不要以為看懂了就能記起來，除非你是記憶力的人，否則其實大部分人都需要時常複習和練習，才能把知識變成是自己的東西。\n做筆記 雖然市面上有許多種筆記軟體可供選擇，個人還是習慣使用文字檔寫個 Markdown 存在雲端，依照語言或項目做分類。當然，選擇自己慣用的方法即可。\n 筆記整理得多了，有時候也能幫助別人\n 例如，對某項技術比較生疏的同事，我就可以用15分鐘整理一份簡略版筆記讓他上手;想在小組內達成某個技術上的共識，也可以做一份簡報在小組會議的時候做分享。\n能夠教別人才是真的懂 常常發現自己縱使做了筆記，也實作了一些成果出來，但當要跟別人說明時卻又說不出個所以然、吚吚啊阿講不到核心重點，事實上是因為自己也不是很懂。\n 撰寫文章也是「刻意練習」的一種方式\n 撰寫文章是最簡單的刻意練習方式，但和作筆記不同。撰寫文章會刻意的將得到的知識重複檢視並加以消化，這個過程往往可以發現自己誤解或不甚了解之處。透過不斷重複這些步驟: 學習 -\u0026gt; 筆記 -\u0026gt; 組織成文章，記錄的資訊量愈大，我們就愈能理解自己關注的領域。","title":"寫部落格與分享"},{"content":"\r\r 在這個部落格裡，我會寫一些與程式語言、軟體架構和Web開發相關的技術筆記，以及我想分享的任何其他內容。歡迎來到這裡讀一兩篇文章並給點寶貴的意見!\n-RCGuo\n My Skills \u0026amp; Experiences: 🏅 Certifications\n AWS Certified Solutions Architect – Associate Oracle Certified Professional, Java SE 6 Programmer  \n\r","permalink":"https://rcguo.github.io/about/","summary":"about","title":"About"}]